# Практичне №6"Бектекінґ, метод гілок та меж"

## 1.а) 
<h3>**Розглядаємо класичну задачку r-рофарбування графа та пошуку його хроматичного числа. Нижче наведено вирішення задачки методом Бектрекінґу. Поясніть як працює код, оцініть його складність.**
### Пояснення коду
- can_color_with_k_colors: 
Функція яка приймає граф у вигляді списку суміжності та число кольорів k.
Вона ініціалізує список кольорів для всіх вершин 
(спочатку жодна вершина не пофарбована, тоб то значення 0) 
і викликає рекурсивну функцію backtrack_coloring. 
Якщо граф можна розфарбувати заданою кількістю кольорів, 
то функція повертає розфарбування інакше – None.


- backtrack_coloring:
Рекурсивна функція яка працює по принципу backtracking.
Вона на кожному кроці намагається присвоїти одній вершині один з можливих кольорів 
від 1 до k:<br><br>
  - Якщо досягнуто останньою вершиною, алгоритм успішно завершується. 
  <br><br>

  - Для кожного кольору перевіряється, чи безпечно його застосувати 
  (що б суміжні вершини не мали однакового кольору) 
  за допомогою функції is_safe_to_color.
  <br><br>

  - У разі успіху для поточної вершини фіксується колір і 
  алгоритм переходить до наступної вершини. 
  <br><br>

  - Якщо подальші виклики повертають невдачу, відбувається rollback:
  встановлюється значення 0 що сигналізує про непофарбовану вершину 
  і пробується наступний колір. <br><br>


- is_safe_to_color:
Допоміжна функція що перевіряє чи не порушує поточне присвоєння кольору умову 
коректного розфарбування графа. Вона переглядає суміжних вершин і, 
якщо якась з них вже пофарбована тим самим кольором повертаємо False.

- find_chromatic_number: 
Функція яка послідовно перевіряє можливість розфарбування графа 
за допомогою 1, 2, …, n кольорів де n – кількість вершин
та повертає перше з мінімальне число кольорів
яке дає змогу коректне розфарбування.

### Оцінка складності алгоритму
У найгіршому випадку алгоритм повинен перевірити всі 
можливі варіанти розфарбування вершин
що дає приблизно k^n комбінацій, де 
k – кількість кольорів та n – кількість вершин.
Однак на практиці багато невдалих 
варіантів відсіюються завчасно за допомогою перевірки суміжних вершин
що зменшує кількість перевірених варіантів

Проте оскільки задача є NP-повною в загальному випадку алгоритм залишається експоненціальним за складністю.


## 1.б)
<h3>**Покращте код, розглядаючи вершини у порядку зменшення їх степеня. Що це дає? Як міняється складність алгоритму.**

### Покращення коду
Покращенний код -> [перейти](Task_1b.py)

- Ми впорядковуємо вершини за зменшенням кількості суміжних
що дозволяє спершу розглядати найбільш обмежені вершини.


- Це дає можливість швидше відкидати невдалі варіанти
оскільки перевірка кольорів для таких вершин має більше обмежень.


### Оцінка складності алгоритму
Складність алгоритму в найгіршому випадку залишається експоненціальною приблизно O(k^n)
де k — кількість кольорів, n — кількість вершин.

Проте при впорядкуванні вершин за спаданням їхнього степеня спочатку 
розглядаються найбільш обмежені вершини.

Це дозволяє швидше виявляти конфлікти та відкидати невдалі розфарбування 
що на практиці значно зменшує кількість рекурсивних викликів і час виконання.


## 2)
<h3>**Нижче наведено псевдокод жадібного алгоритму рофарбуання графа. Запишіть його мовою програмування та протестуйте. Дорведіть коректність алгоритму. Порівняйте цей метод з методом Бектрекінґу, вказавши переваги та недоліки кожного.**</h3>


```
function GreedyColoring_LargestFirst(G):

    # G - граф; припускаю, у нас n вершин від 1 до n

    # Створімо список степенів вершин

    for v in 1..n:

        degrees[v] = кількість суміжних вершин v



    # Тут треба сортувати вершинки за спаданням їх степеня

    sortedVertices = sort(1..n) by degrees[v] descending, break ties by v ascending



    # 0 - не пофарбовано

    colorings = array of size n, filled with 0

    for v in sortedVertices:

        usedColors = empty set



        # Додамо зайняті кольори сусідів до usedColors

        for neighbor in adjacencyList[v]:

            if colorings[neighbor] != 0:

                usedColors.add(colorings[neighbor])



        # Шукаєм перший колір присутній у usedColors

        color = 1

        while color in usedColors:

            color = color + 1

        colorings[v] = color

    return colorings
```

**Доведення коректності алгоритму**


Жадібний алгоритм працює наступним чином:
- Обчислення степенів:
Для кожної вершини ми підраховуємо кількість суміжних вершин, що дає змогу визначити її "обмеженість".

- Упорядкування вершин:
Вершини сортуються за спаданням ступеня – спочатку розглядаються ті, що мають найбільше сусідів, адже для них вибір кольору є критичним.

- Призначення кольорів:
Для кожної вершини алгоритм перевіряє, які кольори вже використані її сусідами, і вибирає найменший натуральний номер, який не використовується.

**Порівняння жадібного алгоритму з методом бек-трекінгу**
Жадібний алгоритм:
  - Переваги:
    - Швидкість. За один прохід по вершинах без перебору численних варіантів.
    - 
    - Простота реалізації. Легко зрозуміти та реалізувати.
    - 
    - Підходить для великих графів. Може бути ефективним для графів з невеликою 
    кількістю кольорів.


  - Недоліки:

    - Не завжди знаходить оптимальне розфарбування (може використати більше кольорів
    ніж мінімально необхідно).

    - Результат сильно залежить від порядку розгляду вершин 
    (хоча сортування за спаданням степеня покращує ситуацію).

**Метод бек-трекінгу:**

- Переваги:

  - Гарантує знаходження оптимального розфарбування (мінімальне хроматичне число).

  - Перебирає всі можливі варіанти, тому, якщо знайде рішення, воно буде коректним.

- Недоліки:

  - Експоненціальна складність в найгіршому випадку (O(kⁿ)), що робить його непридатним для великих графів.

  - Велика кількість рекурсивних викликів та часу на пошук рішення, навіть із застосуванням відсіву невдалих варіантів.